/* Generated By:JavaCC: Do not edit this line. Analisi.java */
package analisiProject;
import java.util.*;
import java.io.*;
import java.net.*;

import org.jgrapht.*;
import org.jgrapht.graph.*;
import org.jgrapht.io.*;
import org.jgrapht.traverse.*;

public class Analisi implements AnalisiConstants {

        public void setIterations(int s) {
                this.iterazioni = s;
        }

        public Analisi() {

        }

  public static Vertexgraph nodoPrec = new Vertexgraph("NULL",0);
  public static Vertexgraph nodoWhile = null;
  public static Vertexgraph nodoIf = null;
  public static Vertexgraph nodoFor = null;
  public static int i = 1;
  public static int iterazioni=0;

  public static Set<Vertexgraph> gen = new HashSet<Vertexgraph>();
  public static Set<Vertexgraph> kill = new HashSet<Vertexgraph>();
  public static Graph<Vertexgraph,DefaultEdge> g = new DefaultDirectedGraph<Vertexgraph,DefaultEdge>(DefaultEdge.class);

        public String main(String args []) throws ParseException, FileNotFoundException {
          Analisi P = new Analisi(new FileInputStream("corpoJava.txt"));

          String riga = "" ;
          String testo = "" ;
          g.addVertex(nodoPrec);

          try{
            riga = P.one_line();
      }
      catch(Exception e){
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        e.printStackTrace();
        }
        return riga;
        }

  static final public String one_line() throws ParseException {
  Vertexgraph s;
  String u= "";
  String risultato="";
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FOR:
      case WHILE:
      case IF:
      case ANNCLASS:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ANNCLASS:
        s = simpleassign();
        g.addVertex(s);
        g.addEdge(nodoPrec,s);
        nodoPrec = s;
        break;
      case WHILE:
        u = whilecycle();
        break;
      case IF:
        u = ifcondition();
        break;
      case FOR:
        u = forcycle();
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
          risultato = "Insieme dei nodi: \u005cn" + g.vertexSet().toString()+"\u005cn"+
                                  "Insieme degli archi: \u005cn" + g.edgeSet().toString()+"\u005cn"+
                                  "Insieme delle var generate: \u005cn"+gen.toString()+"\u005cn"+
                                  "Insieme delle var killate: \u005cn"+kill.toString()+"\u005cn";

          Live obj = new Live(i, kill, gen, g);

          String results = obj.compute_LiveOut(iterazioni);
          {if (true) return risultato+"\u005cn"+results;}
    throw new Error("Missing return statement in function");
  }

  static final public Vertexgraph simpleassign() throws ParseException {
  String s= "";
  Token var=null;
  Token value=null;
  Token op=null;
  String op1="";
  Vertexgraph v = new Vertexgraph();
    var = jj_consume_token(ANNCLASS);
    jj_consume_token(EQUAL);
    s=(var.image);
    Vertexgraph x = new Vertexgraph();
    x.setNodo(s);
    x.setIndex(i);
    s=s+"=";

        Iterator it = kill.iterator();
        boolean presente=false;

        while(it.hasNext()) {
          Vertexgraph tmp = new Vertexgraph();
          tmp = (Vertexgraph) it.next();
          if(tmp.equals(x)) {
            presente=true;
            }
        }

        if(!presente) { kill.add(x);}
        //if( ! kill.contains(x)) { kill.add(x);}

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ANNCLASS:
      var = jj_consume_token(ANNCLASS);
            s = s+(var.image);
                x = new Vertexgraph();
            x.setNodo(var.image);
            x.setIndex(i);
            it = gen.iterator();
                presente=false;

            while(it.hasNext()) {
                        Vertexgraph tmp = new Vertexgraph();
                        tmp = (Vertexgraph) it.next();
                        if(tmp.equals(x)) {
                                presente=true;
                        }
                }
            if(!presente) { gen.add(x);}
                //if(! gen.contains(x)) { gen.add(x);}

      break;
    case INTEGER:
      value = jj_consume_token(INTEGER);
            s=s+(value.image);
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPERATOR:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      op = jj_consume_token(OPERATOR);
           s=s+(op.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ANNCLASS:
        var = jj_consume_token(ANNCLASS);
             Vertexgraph y = new Vertexgraph();
             s = s+(var.image);
             y.setNodo(var.image);
             y.setIndex(i);
             it = gen.iterator();
             presente=false;

             while(it.hasNext()) {
               Vertexgraph tmp = new Vertexgraph();
               tmp = (Vertexgraph) it.next();
                   if(tmp.equals(y)) {
                     presente=true;
                   }
             }
             if(!presente) { gen.add(y);}
             //if(! gen.contains(y)) { gen.add(y);} 

        break;
      case INTEGER:
        value = jj_consume_token(INTEGER);
             s=s+(value.image);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(END);
           v.setNodo(s);
           v.setIndex(i);
           i = i+1;
           {if (true) return v;}
    throw new Error("Missing return statement in function");
  }

  static final public String whilecycle() throws ParseException {
  String s= "";
  Vertexgraph nodo_interno;
  Token var=null;
  Token value=null;
  Token op=null;
  String vars,values,op1="";
  String q="";
  Vertexgraph v = new Vertexgraph();
    jj_consume_token(WHILE);
    jj_consume_token(OPENPAR);
    var = jj_consume_token(ANNCLASS);
          s=(var.image);
          Vertexgraph y = new Vertexgraph();
          y.setNodo(var.image);
          y.setIndex(i);

          Iterator it = gen.iterator();
          boolean presente=false;

            while(it.hasNext()) {
                        Vertexgraph tmp = new Vertexgraph();
                        tmp = (Vertexgraph) it.next();
                        if(tmp.equals(y)) {
                                presente=true;
                        }
                }
                if(!presente) { gen.add(y);}
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIMENSOPER:
      op = jj_consume_token(DIMENSOPER);
            s=s+(op.image);
      break;
    case EQUAL:
      jj_consume_token(EQUAL);
      jj_consume_token(EQUAL);
            s=s+"==";
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    value = jj_consume_token(INTEGER);
    jj_consume_token(CLOSEPAR);
    jj_consume_token(ogr);
          s=s+(value.image);
          v.setNodo(s);
          v.setIndex(i);
          i=i+1;
          g.addVertex(v);
          g.addEdge(nodoPrec,v);
          nodoPrec = v;
          nodoWhile = v;
    nodo_interno = simpleassign();
            g.addVertex(nodo_interno);
            g.addEdge(nodoPrec,nodo_interno);
                nodoPrec = nodo_interno;
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ANNCLASS:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      nodo_interno = simpleassign();
            g.addVertex(nodo_interno);
            g.addEdge(nodoPrec,nodo_interno);
            g.addEdge(nodo_interno,nodoWhile);
            nodoPrec = nodoWhile;
    }
    jj_consume_token(cgr);
                  g.addEdge(nodo_interno,nodoWhile);
                  nodoPrec = nodoWhile;
                  {if (true) return "fine while";}
    throw new Error("Missing return statement in function");
  }

  static final public String forcycle() throws ParseException {
  String s= "";
  Token var=null;
  Token value=null;
  Token op=null;
  Token var2 = null;
  Vertexgraph nodo_interno;
  Vertexgraph nodoIncremento = new Vertexgraph();
  Vertexgraph v = new Vertexgraph();
  Vertexgraph w = new Vertexgraph();
    jj_consume_token(FOR);
    jj_consume_token(OPENPAR);
    var = jj_consume_token(ANNCLASS);
    jj_consume_token(EQUAL);
    value = jj_consume_token(INTEGER);
    jj_consume_token(END);
          s=(var.image)+"="+(value.image);
          v.nodo = s;
          v.index = i;
          g.addVertex(v);
          g.addEdge(nodoPrec,v);

          Vertexgraph y = new Vertexgraph();
          y.setNodo(var.image);
          y.setIndex(i);
          Iterator <Vertexgraph> it = kill.iterator();
          boolean presente=false;
          Vertexgraph tmp = new Vertexgraph();

          while(it.hasNext()){
          tmp = (Vertexgraph) it.next();
                if(tmp.equals(y)){
                  presente = true;
                }
          }

          if(!presente){
            kill.add(y);
          }

          nodoPrec = v;i = i+1;
    var = jj_consume_token(ANNCLASS);
    op = jj_consume_token(DIMENSOPER);
    value = jj_consume_token(INTEGER);
    jj_consume_token(END);
          s=(var.image)+(op.image)+(value.image);
          w.setNodo(s);
          w.setIndex(i);
          y = new Vertexgraph();
          y.setNodo(var.image);
          y.setIndex(i);

          it = gen.iterator();
          presente=false;
          tmp = new Vertexgraph();

          while(it.hasNext()) {
            tmp = (Vertexgraph) it.next();
            if(tmp.equals(y)) {
              presente = true;
                }
          }

          if(! presente){
            gen.add(y);
          }


          g.addVertex(w);
          g.addEdge(nodoPrec,w);
          nodoPrec = w;
          nodoFor = nodoPrec;
          i = i+1;
    var = jj_consume_token(ANNCLASS);
    jj_consume_token(EQUAL);
    var2 = jj_consume_token(ANNCLASS);
    op = jj_consume_token(OPERATOR);
    value = jj_consume_token(INTEGER);
          s=(var.image)+"="+(var2.image)+(op.image)+(value.image);
          nodoIncremento.setNodo(s);
          /*y = new Vertexgraph();
 	  y.setNodo(var.image); y.setIndex(i);

 	  it = kill.iterator();
 	  presente=false;
 	  tmp = new Vertexgraph();

 	  while(it.hasNext()) {
 	    tmp = (Vertexgraph) it.next();
 	    if(tmp.equals(y)) {
 	      presente = true;
		}
	  }
	  if(!presente){
	    kill.add(y);
	  }

	  y = new Vertexgraph();
 	  y.setNodo(var2.image);
 	  y.setIndex(i);

 	  it = gen.iterator();
 	  presente=false;
 	  tmp = new Vertexgraph();

 	  while(it.hasNext()){
 	    tmp = (Vertexgraph) it.next();
 	    if(tmp.equals(y)){
 	      presente = true;
		}
	  }

	  if(! presente){
	    gen.add(y);
	  }*/

    jj_consume_token(CLOSEPAR);
    jj_consume_token(ogr);
    nodo_interno = simpleassign();
            g.addVertex(nodo_interno);
            g.addEdge(nodoPrec,nodo_interno);
                nodoPrec = nodo_interno;
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ANNCLASS:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_4;
      }
      nodo_interno = simpleassign();
            g.addVertex(nodo_interno);
            g.addEdge(nodoPrec,nodo_interno);
            nodoPrec = nodo_interno;
    }
    jj_consume_token(cgr);
          nodoIncremento.setIndex(i);
          y = new Vertexgraph();
          y.setNodo(var.image); y.setIndex(i);

          it = kill.iterator();
          presente=false;
          tmp = new Vertexgraph();

          while(it.hasNext()) {
            tmp = (Vertexgraph) it.next();
            if(tmp.equals(y)) {
              presente = true;
                }
          }
          if(!presente){
            kill.add(y);
          }

          y = new Vertexgraph();
          y.setNodo(var2.image);
          y.setIndex(i);

          it = gen.iterator();
          presente=false;
          tmp = new Vertexgraph();

          while(it.hasNext()){
            tmp = (Vertexgraph) it.next();
            if(tmp.equals(y)){
              presente = true;
                }
          }

          if(! presente){
            gen.add(y);
          }
          g.addVertex(nodoIncremento);
          g.addEdge(nodoPrec,nodoIncremento);
          g.addEdge(nodoIncremento,nodoFor);
          nodoPrec = nodoFor;
          i=i+1;
          {if (true) return "si";}
    throw new Error("Missing return statement in function");
  }

  static final public String ifcondition() throws ParseException {
  String s= "";
  Token var=null;
  Token value=null;
  Token op=null;
  String vars,values,op1="";
  Vertexgraph v = new Vertexgraph();
  Vertexgraph nodo_interno;
    jj_consume_token(IF);
    jj_consume_token(OPENPAR);
    var = jj_consume_token(ANNCLASS);
                s=(var.image);

                Vertexgraph y = new Vertexgraph();
            s = s+(var.image);
            y.setNodo(var.image);
            y.setIndex(i);

                Iterator <Vertexgraph> it = gen.iterator();
                boolean presente=false;
                Vertexgraph tmp = new Vertexgraph();

                while(it.hasNext()) {
                tmp = (Vertexgraph) it.next();
                  if(tmp.equals(y)) {
                    presente = true;
                  }
                }
                if(!presente){
                  gen.add(y);
                }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIMENSOPER:
      op = jj_consume_token(DIMENSOPER);
      break;
    case 25:
      op = jj_consume_token(25);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    value = jj_consume_token(INTEGER);
    jj_consume_token(CLOSEPAR);
    jj_consume_token(ogr);
             s=(var.image)+(op.image)+(value.image);

             g.addVertex(v);

             g.addEdge(nodoPrec,v);
             nodoPrec = v;
             nodoIf = v;
             v.setNodo(s);
                 v.setIndex(i);
                 i=i+1;
    nodo_interno = simpleassign();
            g.addVertex(nodo_interno);
            g.addEdge(nodoPrec,nodo_interno);
                nodoPrec = nodo_interno;
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ANNCLASS:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_5;
      }
      nodo_interno = simpleassign();
            g.addVertex(nodo_interno);
            g.addEdge(nodoPrec,nodo_interno);
            nodoPrec = nodoIf;
    }
    jj_consume_token(cgr);
                nodoPrec = nodoIf;
                {if (true) return "fine if";}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public AnalisiTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[10];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x100e000,0x100e000,0x1040000,0x400,0x1040000,0x400200,0x1000000,0x1000000,0x2000200,0x1000000,};
   }

  /** Constructor with InputStream. */
  public Analisi(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Analisi(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new AnalisiTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Analisi(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new AnalisiTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Analisi(AnalisiTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(AnalisiTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 10; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[26];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 10; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 26; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
